// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: models.kt
// Package: com.lightningkite.butterfly.bluetooth
import Butterfly
import Foundation

public class BleProfileDescription : KDataClass {
    public var services: Map<UUID, BleServiceDescription>
    public init(services: Map<UUID, BleServiceDescription>) {
        self.services = services
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(services)
    }
    public static func == (lhs: BleProfileDescription, rhs: BleProfileDescription) -> Bool { return lhs.services == rhs.services }
    public var description: String { return "BleProfileDescription(services = \(self.services))" }
    public func copy(services: Map<UUID, BleServiceDescription>? = nil) -> BleProfileDescription { return BleProfileDescription(services: services ?? self.services) }
}
public class BleServiceDescription : KDataClass {
    public var debugName: String
    public var primary: Boolean
    public var characteristics: Map<UUID, BleCharacteristicDescription>
    public init(debugName: String, primary: Boolean, characteristics: Map<UUID, BleCharacteristicDescription>) {
        self.debugName = debugName
        self.primary = primary
        self.characteristics = characteristics
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(debugName)
        hasher.combine(primary)
        hasher.combine(characteristics)
    }
    public static func == (lhs: BleServiceDescription, rhs: BleServiceDescription) -> Bool { return lhs.debugName == rhs.debugName && lhs.primary == rhs.primary && lhs.characteristics == rhs.characteristics }
    public var description: String { return "BleServiceDescription(debugName = \(self.debugName), primary = \(self.primary), characteristics = \(self.characteristics))" }
    public func copy(debugName: String? = nil, primary: Boolean? = nil, characteristics: Map<UUID, BleCharacteristicDescription>? = nil) -> BleServiceDescription { return BleServiceDescription(debugName: debugName ?? self.debugName, primary: primary ?? self.primary, characteristics: characteristics ?? self.characteristics) }
}
public class BleCharacteristicDescription : KDataClass {
    public var debugName: String
    public var properties: BleCharacteristicProperties
    public init(debugName: String, properties: BleCharacteristicProperties) {
        self.debugName = debugName
        self.properties = properties
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(debugName)
        hasher.combine(properties)
    }
    public static func == (lhs: BleCharacteristicDescription, rhs: BleCharacteristicDescription) -> Bool { return lhs.debugName == rhs.debugName && lhs.properties == rhs.properties }
    public var description: String { return "BleCharacteristicDescription(debugName = \(self.debugName), properties = \(self.properties))" }
    public func copy(debugName: String? = nil, properties: BleCharacteristicProperties? = nil) -> BleCharacteristicDescription { return BleCharacteristicDescription(debugName: debugName ?? self.debugName, properties: properties ?? self.properties) }
}

public class BleDeviceInfo : KDataClass {
    public var id: String
    public var name: String?
    public init(id: String, name: String?) {
        self.id = id
        self.name = name
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
    }
    public static func == (lhs: BleDeviceInfo, rhs: BleDeviceInfo) -> Bool { return lhs.id == rhs.id && lhs.name == rhs.name }
    public var description: String { return "BleDeviceInfo(id = \(self.id), name = \(self.name))" }
    public func copy(id: String? = nil, name: String?? = .some(nil)) -> BleDeviceInfo { return BleDeviceInfo(id: id ?? self.id, name: invertOptional(name) ?? self.name) }
}

public class BleScanResult : KDataClass {
    public var info: BleDeviceInfo
    public var rssi: Int
    public init(info: BleDeviceInfo, rssi: Int) {
        self.info = info
        self.rssi = rssi
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(info)
        hasher.combine(rssi)
    }
    public static func == (lhs: BleScanResult, rhs: BleScanResult) -> Bool { return lhs.info == rhs.info && lhs.rssi == rhs.rssi }
    public var description: String { return "BleScanResult(info = \(self.info), rssi = \(self.rssi))" }
    public func copy(info: BleDeviceInfo? = nil, rssi: Int? = nil) -> BleScanResult { return BleScanResult(info: info ?? self.info, rssi: rssi ?? self.rssi) }
}

public class BleCharacteristicProperties : KDataClass {
    public var broadcast: Boolean
    public var read: Boolean
    public var writeWithoutResponse: Boolean
    public var write: Boolean
    public var notify: Boolean
    public var indicate: Boolean
    public var authenticatedSignedWrites: Boolean
    public var extendedProperties: Boolean
    public var notifyEncryptionRequired: Boolean
    public var indicateEncryptionRequired: Boolean
    public var writeEncryptionRequired: Boolean
    public init(broadcast: Boolean = false, read: Boolean = false, writeWithoutResponse: Boolean = false, write: Boolean = false, notify: Boolean = false, indicate: Boolean = false, authenticatedSignedWrites: Boolean = false, extendedProperties: Boolean = false, notifyEncryptionRequired: Boolean = false, indicateEncryptionRequired: Boolean = false, writeEncryptionRequired: Boolean = false) {
        self.broadcast = broadcast
        self.read = read
        self.writeWithoutResponse = writeWithoutResponse
        self.write = write
        self.notify = notify
        self.indicate = indicate
        self.authenticatedSignedWrites = authenticatedSignedWrites
        self.extendedProperties = extendedProperties
        self.notifyEncryptionRequired = notifyEncryptionRequired
        self.indicateEncryptionRequired = indicateEncryptionRequired
        self.writeEncryptionRequired = writeEncryptionRequired
        //Necessary properties should be initialized now
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(broadcast)
        hasher.combine(read)
        hasher.combine(writeWithoutResponse)
        hasher.combine(write)
        hasher.combine(notify)
        hasher.combine(indicate)
        hasher.combine(authenticatedSignedWrites)
        hasher.combine(extendedProperties)
        hasher.combine(notifyEncryptionRequired)
        hasher.combine(indicateEncryptionRequired)
        hasher.combine(writeEncryptionRequired)
    }
    public static func == (lhs: BleCharacteristicProperties, rhs: BleCharacteristicProperties) -> Bool { return lhs.broadcast == rhs.broadcast && lhs.read == rhs.read && lhs.writeWithoutResponse == rhs.writeWithoutResponse && lhs.write == rhs.write && lhs.notify == rhs.notify && lhs.indicate == rhs.indicate && lhs.authenticatedSignedWrites == rhs.authenticatedSignedWrites && lhs.extendedProperties == rhs.extendedProperties && lhs.notifyEncryptionRequired == rhs.notifyEncryptionRequired && lhs.indicateEncryptionRequired == rhs.indicateEncryptionRequired && lhs.writeEncryptionRequired == rhs.writeEncryptionRequired }
    public var description: String { return "BleCharacteristicProperties(broadcast = \(self.broadcast), read = \(self.read), writeWithoutResponse = \(self.writeWithoutResponse), write = \(self.write), notify = \(self.notify), indicate = \(self.indicate), authenticatedSignedWrites = \(self.authenticatedSignedWrites), extendedProperties = \(self.extendedProperties), notifyEncryptionRequired = \(self.notifyEncryptionRequired), indicateEncryptionRequired = \(self.indicateEncryptionRequired), writeEncryptionRequired = \(self.writeEncryptionRequired))" }
    public func copy(broadcast: Boolean? = nil, read: Boolean? = nil, writeWithoutResponse: Boolean? = nil, write: Boolean? = nil, notify: Boolean? = nil, indicate: Boolean? = nil, authenticatedSignedWrites: Boolean? = nil, extendedProperties: Boolean? = nil, notifyEncryptionRequired: Boolean? = nil, indicateEncryptionRequired: Boolean? = nil, writeEncryptionRequired: Boolean? = nil) -> BleCharacteristicProperties { return BleCharacteristicProperties(broadcast: broadcast ?? self.broadcast, read: read ?? self.read, writeWithoutResponse: writeWithoutResponse ?? self.writeWithoutResponse, write: write ?? self.write, notify: notify ?? self.notify, indicate: indicate ?? self.indicate, authenticatedSignedWrites: authenticatedSignedWrites ?? self.authenticatedSignedWrites, extendedProperties: extendedProperties ?? self.extendedProperties, notifyEncryptionRequired: notifyEncryptionRequired ?? self.notifyEncryptionRequired, indicateEncryptionRequired: indicateEncryptionRequired ?? self.indicateEncryptionRequired, writeEncryptionRequired: writeEncryptionRequired ?? self.writeEncryptionRequired) }
}

public class BleResponseException : Exception {
    public var value: BleResponseStatus
    public init(value: BleResponseStatus) {
        self.value = value
        super.init(value.name)
        //Necessary properties should be initialized now
    }
}

